using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

namespace com.darktable.utility
{
    public class TagPostProcessor : AssetModificationProcessor
    {
        private const string k_Header = "/* <auto-generated> DO NOT MODIFY\n (created by TagPostProcessor.cs. File->Save Project will usually trigger an update of this file) */\n\n";
        private const string k_StandardAssets = "Standard Assets";
        private const string k_DirectoryName = "Scripts/Tag Constants";
        private const string k_FileName = "TagConstants.cs";
        private static readonly string[] k_SavedAssets = new[] { "NavMeshAreas.asset", "TagManager.asset", "EditorBuildSettings.asset" };

        private const string k_AsmDefFilename = "com.darktable.tagconstants.asmdef";
        private const string k_AsmDefContents = "{\"name\": \"com.darktable.tagconstants\"}";

        private static readonly Regex k_NonWordRegEx = new Regex("[^a-zA-Z0-9]");
        private static readonly Regex k_PrefixNumberRegEx = new Regex("^[0-9]");

        [InitializeOnLoadMethod]
        private static void ValidateTagConstants()
        {
            string rootPath = Path.Combine(Application.dataPath, k_StandardAssets, k_DirectoryName);

            if (!Directory.Exists(rootPath))
            {
                UpdateTagsConstants();

                return;
            }

            string fileName = Path.Combine(rootPath, k_FileName);

            if (!File.Exists(fileName))
            {
                UpdateTagsConstants();
            }
        }

        private static string[] OnWillSaveAssets(string[] paths)
        {
            foreach (string path in paths)
            {
                string filename = Path.GetFileName(path);

                foreach (string asset in k_SavedAssets)
                {
                    if (filename.Equals(asset, StringComparison.InvariantCultureIgnoreCase))
                    {
                        UpdateTagsConstants();

                        return paths;
                    }
                }
            }

            return paths;
        }

        private static string SanitizeVariableName(string label)
        {
            string sanitisedTag = k_NonWordRegEx.Replace(label, "_");
            sanitisedTag = k_PrefixNumberRegEx.Replace(sanitisedTag, match => "_" + match.Value);

            return sanitisedTag;
        }

        private static void UpdateTagList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, string>();

            outfile.Append("public static class TagConstant\n{\n");

            foreach (string tag in InternalEditorUtility.tags)
            {
                string sanitisedTag = SanitizeVariableName(tag);

                if (nameCollisions.TryGetValue(sanitisedTag, out var collision))
                {
                    Debug.LogError($"Two tags with same sanitized name: \"{collision}\", \"{tag}\" = \"{sanitisedTag}\"");

                    continue;
                }

                nameCollisions.Add(sanitisedTag, tag);

                outfile.Append($"    public const string {sanitisedTag} = \"{tag}\";\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateLayerList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, string>();

            outfile.Append("public static class LayerConstant\n{\n");

            foreach (string layer in InternalEditorUtility.layers)
            {
                string sanitizedLayer = SanitizeVariableName(layer);

                if (nameCollisions.TryGetValue(sanitizedLayer, out string collision))
                {
                    Debug.LogError($"Two layers with same sanitized name: \"{collision}\", \"{layer}\" = \"{sanitizedLayer}\"");

                    continue;
                }

                nameCollisions.Add(sanitizedLayer, layer);

                outfile.Append($"    public const int {sanitizedLayer} = {LayerMask.NameToLayer(layer)};\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("[System.Flags]\npublic enum LayerFlag\n{\n");

            foreach (var kvp in nameCollisions)
            {
                outfile.Append($"    {kvp.Key} = 1 << {LayerMask.NameToLayer(kvp.Value)},\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("public static class LayerName\n{\n");

            foreach (var kvp in nameCollisions)
            {
                outfile.Append($"    public const string {kvp.Key} = \"{kvp.Value}\";\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateSortingLayerList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, string>();

            outfile.Append("public static class SortingLayerConstant\n{\n");

            foreach (var sortingLayer in SortingLayer.layers)
            {
                string name = sortingLayer.name;
                string sanitizedLayer = SanitizeVariableName(name);

                if (nameCollisions.TryGetValue(sanitizedLayer, out string collision))
                {
                    Debug.LogError($"Two layers with same sanitized name: \"{collision}\", \"{name}\" = \"{sanitizedLayer}\"");

                    continue;
                }

                nameCollisions.Add(sanitizedLayer, name);

                outfile.Append($"    public const int {sanitizedLayer} = {sortingLayer.id};\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateNavAgentsList(StringBuilder outfile)
        {
            outfile.Append("public static class NavMeshAgentID\n{\n");
            var nameCollisions = new Dictionary<string, string>();
            int count = NavMesh.GetSettingsCount();
            for (var i = 0; i < count; i++)
            {
                int agentTypeID = NavMesh.GetSettingsByIndex(i).agentTypeID;
                string agentName = NavMesh.GetSettingsNameFromID(agentTypeID);
                string sanitizedAgentName = SanitizeVariableName(agentName);

                if (nameCollisions.TryGetValue(sanitizedAgentName, out var collision))
                {
                    Debug.LogError($"Two layers with same sanitized name: \"{collision}\", \"{agentName}\" = \"{sanitizedAgentName}\"");

                    continue;
                }

                nameCollisions.Add(sanitizedAgentName, agentName);

                outfile.Append($"    public const int {sanitizedAgentName} = {agentTypeID};\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateSceneList(StringBuilder outfile)
        {
            outfile.Append("public static class SceneName\n{\n");
            var nameCollisions = new Dictionary<string, string>();
            int count = SceneManager.sceneCountInBuildSettings;

            var sceneNames = new string[count];

            for (var i = 0; i < count; i++)
            {
                string scenePath = SceneUtility.GetScenePathByBuildIndex(i);

                if (string.IsNullOrEmpty(scenePath))
                {
                    continue;
                }

                string sceneName = Path.GetFileNameWithoutExtension(scenePath);
                string sanitizedSceneName = SanitizeVariableName(sceneName);

                if (nameCollisions.TryGetValue(sanitizedSceneName, out var collision))
                {
                    Debug.LogError($"Two scenes with same sanitized name: \"{collision}\", \"{sceneName}\" = \"{sanitizedSceneName}\"");

                    continue;
                }

                nameCollisions.Add(sanitizedSceneName, sceneName);

                outfile.Append($"    public const string {sanitizedSceneName} = \"{sceneName}\";\n");
                sceneNames[i] = sanitizedSceneName;
            }

            outfile.Append("}\n\n");

            outfile.Append("public static class SceneIndex\n{\n");

            for (var i = 0; i < count; i++)
            {
                string name = sceneNames[i];

                if (string.IsNullOrEmpty(name))
                {
                    continue;
                }

                outfile.Append($"    public const int {name} = {i};\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateTagsConstants()
        {
            string rootPath = Path.Combine(Application.dataPath, k_StandardAssets, k_DirectoryName);

            if (!Directory.Exists(rootPath))
            {
                Directory.CreateDirectory(rootPath);
            }

            string asmDefPath = Path.Combine(rootPath, k_AsmDefFilename);

            if (!File.Exists(asmDefPath))
            {
                File.WriteAllText(asmDefPath, k_AsmDefContents);
            }

            string filePath = Path.Combine(rootPath, k_FileName);
            string current = null;

            if (File.Exists(filePath))
            {
                current = File.ReadAllText(filePath);
            }

            var builder = new StringBuilder(k_Header, 4096);
            UpdateTagList(builder);

            UpdateSortingLayerList(builder);

            UpdateLayerList(builder);

            UpdateNavAgentsList(builder);

            UpdateSceneList(builder);

            var updated = builder.ToString();

            if (!string.Equals(current, updated))
            {
                Debug.Log("Generating tag constants file");
                File.WriteAllText(filePath, updated);

                AssetDatabase.Refresh();
            }
        }
    }
}
