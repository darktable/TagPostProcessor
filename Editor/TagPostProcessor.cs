using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;
#if XR_INTERACTION
using UnityEngine.XR.Interaction.Toolkit;
#endif

namespace com.darktable.utility
{
    public class TagPostProcessor : AssetModificationProcessor
    {
        private const string k_Header =
            "/* <auto-generated> DO NOT MODIFY\n (created by TagPostProcessor.cs. File->Save Project will usually trigger an update of this file) */\n\n";

        private const string k_StandardAssets = "Standard Assets";
        private const string k_DirectoryName = "Scripts/Tag Constants";
        private const string k_FileName = "TagConstants.cs";

        private static readonly string[] k_SavedAssets = new[]
            { "NavMeshAreas.asset", "TagManager.asset", "EditorBuildSettings.asset" };

        private const string k_AsmDefFilename = "com.darktable.tagconstants.asmdef";
        private const string k_AsmDefContents = "{\"name\": \"com.darktable.tagconstants\"}";

        private static readonly string[] s_WatchedAssets = new[]
            { "NavMeshAreas.asset", "TagManager.asset", "EditorBuildSettings.asset", "InteractionLayerSettings.asset" };

        private static readonly string[] s_WatchedTypes = new[] { "UniversalRenderPipelineGlobalSettings" };

        private static readonly Regex s_NonWordRegEx = new Regex("[^a-zA-Z0-9]");
        private static readonly Regex s_PrefixNumberRegEx = new Regex("^[0-9]");

        [InitializeOnLoadMethod]
        private static void ValidateTagConstants()
        {
            var rootPath = Path.Combine(Application.dataPath, k_StandardAssets, k_DirectoryName);

            if (!Directory.Exists(rootPath))
            {
                UpdateTagsConstants();

                return;
            }

            var fileName = Path.Combine(rootPath, k_FileName);

            if (!File.Exists(fileName))
            {
                UpdateTagsConstants();
            }
        }

        [MenuItem("Tools/Utilities/Update TagConstants.cs")]
        private static void UpdateTagConstantsMenu()
        {
            AssetDatabase.SaveAssets();
            UpdateTagsConstants();
        }

        private static string[] OnWillSaveAssets(string[] paths)
        {
            foreach (var path in paths)
            {
                var filename = Path.GetFileName(path);

                foreach (var asset in s_WatchedAssets)
                {
                    if (filename.Equals(asset, StringComparison.InvariantCultureIgnoreCase))
                    {
                        UpdateTagsConstants();

                        return paths;
                    }
                }

                var typeName = AssetDatabase.GetMainAssetTypeAtPath(path)?.Name;

                foreach (var type in s_WatchedTypes)
                {
                    if (type.Equals(typeName))
                    {
                        UpdateTagsConstants();

                        return paths;
                    }
                }
            }

            return paths;
        }

        private static string SanitizeVariableName(string label)
        {
            var sanitisedTag = s_NonWordRegEx.Replace(label, "_");
            sanitisedTag = s_PrefixNumberRegEx.Replace(sanitisedTag, match => "_" + match.Value);

            return sanitisedTag;
        }

        private static void UpdateTagList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, string>();

            outfile.Append("public static class TagConstant\n{\n");

            foreach (var tag in InternalEditorUtility.tags)
            {
                var sanitisedTag = SanitizeVariableName(tag);

                if (!nameCollisions.TryAdd(sanitisedTag, tag))
                {
                    Debug.LogWarning($"Two tags with same sanitized name: \"{tag}\", \"{tag}\" => \"{sanitisedTag}\"");

                    continue;
                }

                outfile.Append($"    public const string {sanitisedTag} = \"{tag}\";\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateLayerList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, (string name, int index)>();

            outfile.Append("public static class LayerConstant\n{\n");

            foreach (var layer in InternalEditorUtility.layers)
            {
                var sanitizedLayer = SanitizeVariableName(layer);
                var index = LayerMask.NameToLayer(layer);

                if (!nameCollisions.TryAdd(sanitizedLayer, (layer, index)))
                {
                    Debug.LogWarning(
                        $"Two layers with same sanitized name: \"{layer}\", \"{layer}\" => \"{sanitizedLayer}\"");

                    continue;
                }

                outfile.Append($"    public const int {sanitizedLayer} = {index};\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("[System.Flags]\npublic enum LayerFlag\n{\n");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.Append($"    {key} = 1 << {index},\n");
            }

            outfile.Append("}\n\n");

            outfile.AppendLine("public enum LayerEnum\n{");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.AppendLine($"    {key} = {index},");
            }

            outfile.AppendLine("}\n");

            outfile.Append("public static class LayerName\n{\n");

            foreach (var (key, (name, _)) in nameCollisions)
            {
                outfile.Append($"    public const string {key} = \"{name}\";\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateSortingLayerList(StringBuilder outfile)
        {
            var nameCollisions = new Dictionary<string, string>();

            outfile.Append("public static class SortingLayerConstant\n{\n");

            foreach (var sortingLayer in SortingLayer.layers)
            {
                var name = sortingLayer.name;
                var sanitizedLayer = SanitizeVariableName(name);

                if (!nameCollisions.TryAdd(sanitizedLayer, name))
                {
                    Debug.LogWarning(
                        $"Two layers with same sanitized name: \"{name}\", \"{name}\" => \"{sanitizedLayer}\"");

                    continue;
                }

                outfile.Append($"    public const int {sanitizedLayer} = {sortingLayer.id};\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateNavAgentsList(StringBuilder outfile)
        {
            outfile.Append("public static class NavMeshAgentID\n{\n");
            var nameCollisions = new Dictionary<string, string>();
            var count = NavMesh.GetSettingsCount();
            for (var i = 0; i < count; i++)
            {
                var agentTypeID = NavMesh.GetSettingsByIndex(i).agentTypeID;
                var agentName = NavMesh.GetSettingsNameFromID(agentTypeID);
                var sanitizedAgentName = SanitizeVariableName(agentName);

                if (!nameCollisions.TryAdd(sanitizedAgentName, agentName))
                {
                    Debug.LogWarning(
                        $"Two layers with same sanitized name: \"{agentName}\", \"{agentName}\" => \"{sanitizedAgentName}\"");

                    continue;
                }

                outfile.Append($"    public const int {sanitizedAgentName} = {agentTypeID};\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateSceneList(StringBuilder outfile)
        {
            outfile.Append("public static class SceneName\n{\n");
            var nameCollisions = new Dictionary<string, string>();
            var count = SceneManager.sceneCountInBuildSettings;

            var sceneInfo = new List<(string, int)>(count);

            for (var i = 0; i < count; i++)
            {
                var scenePath = SceneUtility.GetScenePathByBuildIndex(i);

                if (string.IsNullOrEmpty(scenePath))
                {
                    continue;
                }

                var sceneName = Path.GetFileNameWithoutExtension(scenePath);
                var sanitizedSceneName = SanitizeVariableName(sceneName);

                if (!nameCollisions.TryAdd(sanitizedSceneName, sceneName))
                {
                    Debug.LogWarning(
                        $"Two scenes with same sanitized name: \"{sceneName}\", \"{sceneName}\" => \"{sanitizedSceneName}\"");

                    continue;
                }

                var loadedScene = EditorSceneManager.GetSceneByPath(scenePath);
                int buildIndex;

                if (loadedScene.IsValid())
                {
                    buildIndex = loadedScene.buildIndex;
                }
                else
                {
                    var unloadedScene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.AdditiveWithoutLoading);

                    buildIndex = unloadedScene.buildIndex;

                    EditorSceneManager.UnloadSceneAsync(unloadedScene);
                }

                if (buildIndex < 0)
                {
                    continue;
                }

                sceneInfo.Add((sanitizedSceneName, buildIndex));

                outfile.Append($"    public const string {sanitizedSceneName} = \"{sceneName}\";\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("public static class SceneIndex\n{\n");

            foreach (var (name, buildIndex) in sceneInfo)
            {
                if (string.IsNullOrEmpty(name) || buildIndex < 0)
                {
                    continue;
                }

                outfile.Append($"    public const int {name} = {buildIndex};\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("public enum SceneEnum\n{\n");

            foreach (var (name, buildIndex) in sceneInfo)
            {
                if (string.IsNullOrEmpty(name) || buildIndex < 0)
                {
                    continue;
                }

                outfile.Append($"    {name} = {buildIndex},\n");
            }

            outfile.Append("}\n\n");
        }

        private static void UpdateTagsConstants()
        {
            var rootPath = Path.Combine(Application.dataPath, k_StandardAssets, k_DirectoryName);

            if (!Directory.Exists(rootPath))
            {
                Directory.CreateDirectory(rootPath);
            }

            var asmDefPath = Path.Combine(rootPath, k_AsmDefFilename);

            if (!File.Exists(asmDefPath))
            {
                File.WriteAllText(asmDefPath, k_AsmDefContents);
            }

            var filePath = Path.Combine(rootPath, k_FileName);
            string current = null;

            if (File.Exists(filePath))
            {
                current = File.ReadAllText(filePath);
            }

            var builder = new StringBuilder(k_Header, 4096);
            UpdateTagList(builder);

            UpdateSortingLayerList(builder);

            UpdateLayerList(builder);

            UpdateNavAgentsList(builder);

            UpdateSceneList(builder);

            UpdateInteractionLayers(builder);

            UpdateRenderingLayers(builder);

            var updated = builder.ToString();

            if (!string.Equals(current, updated))
            {
                Debug.Log("Generating tag constants file");
                File.WriteAllText(filePath, updated);

                AssetDatabase.Refresh();
            }
        }

        private static void UpdateInteractionLayers(StringBuilder outfile)
        {
#if XR_INTERACTION
            var nameCollisions = new Dictionary<string, (string name, int index)>();

            outfile.Append("public static class InteractionLayerConstant\n{\n");

            for (var i = 0; i < 32; i++)
            {
                var layer = InteractionLayerMask.LayerToName(i);

                if (string.IsNullOrEmpty(layer))
                {
                    continue;
                }

                var sanitizedLayer = SanitizeVariableName(layer);

                if (!nameCollisions.TryAdd(sanitizedLayer, (layer, i)))
                {
                    Debug.LogWarning(
                        $"Two layers with same sanitized name: \"{layer}\", \"{layer}\" => \"{sanitizedLayer}\"");

                    continue;
                }

                outfile.Append($"    public const int {sanitizedLayer} = {i};\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("[System.Flags]\npublic enum InteractionLayerFlag\n{\n");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.Append($"    {key} = 1 << {index},\n");
            }

            outfile.Append("}\n\n");

            outfile.AppendLine("public enum InteractionLayerEnum\n{");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.AppendLine($"    {key} = {index},");
            }

            outfile.AppendLine("}\n");

            outfile.Append("public static class InteractionLayerName\n{\n");

            foreach (var (key, (name, _)) in nameCollisions)
            {
                outfile.Append($"    public const string {key} = \"{name}\";\n");
            }

            outfile.Append("}\n\n");
#endif
        }

        private static void UpdateRenderingLayers(StringBuilder outfile)
        {
#if UNITY_URP
            var nameCollisions = new Dictionary<string, (string name, int index)>();

            var pipeline = QualitySettings.renderPipeline;

            if (pipeline == null)
            {
                return;
            }

            var layerMaskNames = pipeline.renderingLayerMaskNames;

            outfile.Append("public static class RenderingLayerMaskConstant\n{\n");

            for (var i = 0; i < layerMaskNames.Length; i++)
            {
                var layer = layerMaskNames[i];

                if (string.IsNullOrEmpty(layer))
                {
                    continue;
                }

                var sanitizedLayer = SanitizeVariableName(layer);

                if (!nameCollisions.TryAdd(sanitizedLayer, (layer, i)))
                {
                    Debug.LogWarning(
                        $"Two layers with same sanitized name: \"{layer}\", \"{layer}\" => \"{sanitizedLayer}\"");

                    continue;
                }

                outfile.Append($"    public const int {sanitizedLayer} = {i};\n");
            }

            outfile.Append("}\n\n");

            outfile.Append("[System.Flags]\npublic enum RenderingLayerMaskFlag\n{\n");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.Append($"    {key} = 1 << {index},\n");
            }

            outfile.Append("}\n\n");

            outfile.AppendLine("public enum RenderingLayerMaskEnum\n{");

            foreach (var (key, (_, index)) in nameCollisions)
            {
                outfile.AppendLine($"    {key} = {index},");
            }

            outfile.AppendLine("}\n");

            outfile.Append("public static class RenderingLayerMaskName\n{\n");

            foreach (var (key, (name, _)) in nameCollisions)
            {
                outfile.Append($"    public const string {key} = \"{name}\";\n");
            }

            outfile.Append("}\n\n");
#endif
        }
    }
}
